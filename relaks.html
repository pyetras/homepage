<!DOCTYPE html><html class="article"><head><title>The Language of the Future&lt;br/&gt;Does Your Job For You</title><meta content="text/html; charset=UTF8" http-equiv="content-type" /><meta content="Hi, my name is Piotr and I&#39;m a Software Engineer living in London." name="description" /><meta content="width=device-width, minimum-scale=1.0, maximum-scale=1.0" name="viewport" /><link href="/images/favicon.png" rel="shortcut icon" /><link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.4.0/css/font-awesome.min.css" rel="stylesheet"><!--inject:vendor:css--><!--endinject--><!--inject:css--><link rel="stylesheet" href="./assets/styles/style.css"><!--endinject--></link></head><body class="article"><noscript><iframe src="//www.googletagmanager.com/ns.html?id=GTM-TFCCMW"
height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
<script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
'//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
})(window,document,'script','dataLayer','GTM-TFCCMW');</script>
<header><div class="homepage"><a class="text" href="/">⟵ Homepage</a></div><div class="title-container"><p class="subtitle author"><a href="/">Piotr Sokólski</a></p><h1>The Language of the Future<br/>Does Your Job For You</h1></div></header><div class="main"><div class="article-container"><article><p>I love the idea behind declarative programming languages: you start by specifying the result you want to achieve rather than how you want to achieve it. Some, such as SQL hide away the complexity by providing a fixed set of highly optimised and yet expressive high-level operations such as SELECT, JOIN etc. Others, such as my personal favourite, Prolog, allow achieving similar results while granting unlimited flexibility.</p>
<p>The design of Prolog is simple and beautiful. It basically does just two things, and it does them really well: allow you to specify a search tree for your problem and then traverse that tree.</p>
<p>The devil is in the details though: Prolog's logic based rules are pure and merciless. One overlooked condition, and the program would be stuck forever, generating and mindlessly following an infinite number of branches in the tree, while the solution might lie just in the <em>sibling</em> of one of the looping nodes.</p>
<p>In my opinion the language of the future does not <em>traverse</em> the tree specified by the programmer, whether it's an Abstract Syntax Tree that is translated literally to a sequence of operations, or a tree of theorems and conclusions traversed by Prolog. Instead it <em>explores</em> it.</p>
<p>Consider the following statement:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">val</span> k = choose between <span class="dv">1</span> and <span class="dv">5</span>
select k where k == <span class="dv">2</span></code></pre></div>
<p>Looks simple enough, right? With a slight syntax alterations Prolog could do it. SQL could do it, if <code>choose</code> was a function that generates a table of numbers. Even in Python, a program where <code>choose</code> is replaced by <code>range</code> would look similar enough. How about</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">val</span> k = choose between <span class="fl">1.0</span> and <span class="fl">5.0</span>
select k where k == <span class="fl">2.0</span></code></pre></div>
<p>In theory it should be unsolvable by Prolog in the straightforward, left to right tree traversal - there is infinitely many numbers between 1.0 and 2.0. An implementation of this search based on computer's representation of floating numbers would eventually finish. If the function evaluating k was more expensive it's easy to see how a standard left-to-right search would take a long time. The same happens if we add more parameters to the function - the search space grows exponentially. If we knew that the function could be solved using e.g. <a href="https://en.wikipedia.org/wiki/Newton%27s_method_in_optimization">Newton's method</a>, we could write a much more efficient search procedure that would return a result within an acceptable error margin.</p>
<p>How about</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">val</span> k = choose between <span class="dv">2</span> and <span class="dv">10</span>
<span class="fu">optimize</span> (knnExperiment k) by errorRate desc limit <span class="dv">10</span></code></pre></div>
<p>What I would like this expression to do is to run a K Nearest Neighbors algorithm ten times while trying to minimize <code>errorRate</code> by tweaking the parameter k. It turns out that KNN and other machine learning algorithms can be successfully <a href="https://github.com/JasperSnoek/spearmint">modelled as Gaussian Processes</a> and iteratively optimised wrt. their hyperparameters.</p>
<h2 id="relaks">Relaks</h2>
<p>Above snippets are valid programs in Relaks - a Scala DSL. The similarities between Relaks and SQL are intentional - it uses a powerful <em>experiment database</em> metaphor to define search space. The columns are inputs and outputs of the optimised algorithms - hyperparameters and evaluated fitness. Once defined, a table can be queried using familiar SQL-like syntax - LIMIT, WHERE etc. Under the hood the table doesn't actually exist - it is generated row by row, using hints from the query to limit possibly very large search space. For example a WHERE clause would narrow down the set of hyperparameters and LIMIT would decrease the number of performed search iterations. Let's take a look at a comprehensive example:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">object</span> Program <span class="kw">extends</span>
    <span class="fu">DSLOptimizerInterpreter</span>(SpearmintOptimizer) {
  <span class="kw">val</span> x = choose between <span class="fl">0.0</span> and <span class="fl">15.0</span>
  <span class="kw">val</span> y = choose between -<span class="fl">5.0</span> and <span class="fl">10.0</span>

  <span class="kw">val</span> result = <span class="fu">optimize</span> (x, y) map { <span class="kw">case</span> <span class="fu">Tup</span>(x, y) =&gt;
    <span class="kw">val</span> res = <span class="fu">to</span> (branin _) <span class="fu">apply</span> (x, y)
    res as &#39;result
  } by &#39;result
    limit <span class="dv">100</span>

  <span class="fu">store</span>(result)
}

Program.<span class="fu">dump</span>()</code></pre></div>
<p>This program will try to find a minimum of the Branin-Hoo function within the specified search space, using up to 100 iterations of an optimisation algorithm. <code>store</code> and <code>dump</code> are hints to the interpreter to materialise and print out the experiment table at the end of the program.</p>
<h2 id="work-in-progress...">Work in progress...</h2>
<p>An experimental implementation of a language of the future with a Gaussian Process optimiser as a DSL for Scala is available on <a href="//github.com/pyetras/relaks">Github</a>. It consists of LINQ-like extensions for Scala with a query optimiser that can reorder SQL operators and fuse them with hyperparameter definitions. I have also implemented an interpreter for the language and a caching system that can factor out common operations between subsequent optimiser runs and cache the results in memory. This was part of my <a href="/relaks.pdf">Master's Thesis</a>.</p></article></div></div><!--inject:vendor:js--><!--endinject--><!--inject:js--><!--endinject--></body></html>
